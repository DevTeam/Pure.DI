// <auto-generated/>
#if !PUREDI_API_SUPPRESSION || PUREDI_API_V2
#pragma warning disable

#if !PUREDI_API_FUNC_SUPPRESSION
namespace System
{
#if NET20
    internal delegate TResult Func<out TResult>();
#endif
#if NET20 || NET35
    internal delegate TResult Func<in T, out TResult>(T arg);
    internal delegate TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2);
    internal delegate TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3);
    internal delegate TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    internal delegate TResult Func<in T1, in T2, in T3, in T4, in T5, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    internal delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    internal delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    internal delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
#endif
}
#endif

namespace Pure.DI
{
    using System;

    /// <summary>
    /// Defines binding lifetimes for dependencies.
    /// <example>
    /// Binding as Singleton:
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&gt;().As(Lifetime.Singleton).To&lt;Dependency&gt;();
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="Pure.DI.DI.Setup"/>
    /// <seealso cref="IBinding.As"/>
    /// <seealso cref="IConfiguration.DefaultLifetime"/>
    /// <seealso cref="IConfiguration.DefaultLifetime{T}"/>
    internal enum Lifetime
    {
        /// <summary>
        /// Creates a new dependency instance for each injection (default behavior). Default behavior can be changed by <see cref="IConfiguration.DefaultLifetime"/> and <see cref="IConfiguration.DefaultLifetime{T}"/>.
        /// <example>
        /// Explicit transient binding:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.Transient).To&lt;Dependency&gt;();
        /// </code>
        /// Default behavior (equivalent):
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <seealso cref="IConfiguration.DefaultLifetime"/>
        /// <seealso cref="IConfiguration.DefaultLifetime{T}"/>
        Transient,

        /// <summary>
        /// Maintains a single instance per composition.
        /// <example>
        /// Singleton binding:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;().As(Lifetime.Singleton).To&lt;Service&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Singleton,

        /// <summary>
        /// Single instance per composition root.
        /// <example>
        /// Per-resolve binding:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IProcessor&gt;().As(Lifetime.PerResolve).To&lt;Processor&gt;();
        /// </code>
        /// </example>
        /// </summary>
        PerResolve,

        /// <summary>
        /// Reuses instances within code blocks to reduce allocations.
        /// <example>
        /// Per-block binding:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;ILogger&gt;().As(Lifetime.PerBlock).To&lt;Logger&gt;();
        /// </code>
        /// </example>
        /// </summary>
        PerBlock,

        /// <summary>
        /// Single instance per dependency scope.
        /// <example>
        /// Scoped binding:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDatabase&gt;().As(Lifetime.Scoped).To&lt;Database&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Scoped
    }
    
    /// <summary>
    /// Provides configuration hints for fine-tuning code generation behavior.
    /// <example>
    /// <code>
    /// // Resolve = Off
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
    /// </code>
    /// or using the API call <see cref="IConfiguration.Hint"/>:
    /// <code>
    /// DI.Setup("Composition")
    ///     .Hint(Hint.Resolve, "Off")
    ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="IConfiguration.Hint"/>
    internal enum Hint
    {
        /// <summary>
        /// Enables/disables generation of Resolve methods. Default: <c>On</c>.
        /// <example>
        /// <code>
        /// // Resolve = Off
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.Resolve, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Resolve,

        /// <summary>
        /// Enables/disables generation of OnNewInstance hooks. Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // OnNewInstance = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstance, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstance,

        /// <summary>
        /// Enables/disables partial method generation for OnNewInstance. Default: <c>On</c>.
        /// <example>
        /// <code>
        /// // OnNewInstancePartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstancePartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstancePartial,

        /// <summary>
        /// Regex filter for instance types in OnNewInstance hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnNewInstanceImplementationTypeNameRegularExpression = Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceImplementationTypeNameRegularExpression, "Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstanceImplementationTypeNameRegularExpression,

        /// <summary>
        /// Wildcard filter for instance types in OnNewInstance hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnNewInstanceImplementationTypeNameWildcard = *Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(OnNewInstanceImplementationTypeNameWildcard, "*Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstanceImplementationTypeNameWildcard,

        /// <summary>
        /// Regex filter for tags in OnNewInstance hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnNewInstanceTagRegularExpression = IDependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceTagRegularExpression, "IDependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstanceTagRegularExpression,

        /// <summary>
        /// Wildcard filter for tags in OnNewInstance hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnNewInstanceTagWildcard = *IDependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceTagWildcard, "*IDependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstanceTagWildcard,

        /// <summary>
        /// Regex filter for lifetimes in OnNewInstance hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnNewInstanceLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstanceLifetimeRegularExpression,

        /// <summary>
        /// Wildcard filter for lifetimes in OnNewInstance hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnNewInstanceLifetimeWildcard = *Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceLifetimeWildcard, "*Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewInstanceLifetimeWildcard,

        /// <summary>
        /// Enables/disables dependency injection interception hooks. Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjection = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjection, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjection,

        /// <summary>
        /// Enables/disables partial method generation for dependency injection hooks. Default: <c>On</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionPartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionPartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionPartial,

        /// <summary>
        /// Regex filter for implementation types in dependency injection hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionImplementationTypeNameRegularExpression = Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionImplementationTypeNameRegularExpression, "Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionImplementationTypeNameRegularExpression,

        /// <summary>
        /// Wildcard filter for implementation types in dependency injection hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionImplementationTypeNameWildcard = *Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionImplementationTypeNameWildcard, "*Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionImplementationTypeNameWildcard,

        /// <summary>
        /// Regex filter for contract types in dependency injection hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionContractTypeNameRegularExpression = IDependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionContractTypeNameRegularExpression, "IDependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionContractTypeNameRegularExpression,

        /// <summary>
        /// Wildcard filter for contract types in dependency injection hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionContractTypeNameWildcard = *IDependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionContractTypeNameWildcard, "*IDependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionContractTypeNameWildcard,

        /// <summary>
        /// Regex filter for tags in dependency injection hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionTagRegularExpression = MyTag
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;("MyTag").To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionTagRegularExpression, "MyTag")
        ///     .Bind&lt;IDependency&gt;("MyTag").To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionTagRegularExpression,

        /// <summary>
        /// Wildcard filter for tags in dependency injection hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionTagWildcard = MyTag
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;("MyTag").To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionTagWildcard, "MyTag")
        ///     .Bind&lt;IDependency&gt;("MyTag").To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionTagWildcard,

        /// <summary>
        /// Regex filter for lifetimes in dependency injection hooks. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionLifetimeRegularExpression,

        /// <summary>
        /// Wildcard filter for lifetimes in dependency injection hooks. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionLifetimeWildcard = *Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionLifetimeWildcard, "*Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnDependencyInjectionLifetimeWildcard,

        /// <summary>
        /// Enables/disables unresolved dependency handlers. Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolve = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolve, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolve,

        /// <summary>
        /// Enables/disables partial method generation for unresolved dependency handlers. Default: <c>On</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolvePartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolvePartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolvePartial,

        /// <summary>
        /// Regex filter for contract types in unresolved dependency handlers. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolveContractTypeNameRegularExpression = OtherType
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveContractTypeNameRegularExpression, "OtherType")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolveContractTypeNameRegularExpression,

        /// <summary>
        /// Wildcard filter for contract types in unresolved dependency handlers. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolveContractTypeNameWildcard = *OtherType
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveContractTypeNameWildcard, "*OtherType")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolveContractTypeNameWildcard,

        /// <summary>
        /// Regex filter for tags in unresolved dependency handlers. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolveTagRegularExpression = MyTag
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveTagRegularExpression, "MyTag")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolveTagRegularExpression,

        /// <summary>
        /// Wildcard filter for tags in unresolved dependency handlers. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolveTagWildcard = MyTag
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveTagWildcard, "MyTag")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolveTagWildcard,

        /// <summary>
        /// Regex filter for lifetimes in unresolved dependency handlers. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolveLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolveLifetimeRegularExpression,

        /// <summary>
        /// Wildcard filter for lifetimes in unresolved dependency handlers. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // OnCannotResolveLifetimeWildcard = *Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveLifetimeWildcard, "*Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnCannotResolveLifetimeWildcard,

        /// <summary>
        /// Enables/disables composition root registration event handlers. Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // OnNewRoot = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewRoot, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewRoot,

        /// <summary>
        /// Enables/disables partial method generation for composition root events. Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // OnNewRootPartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewRootPartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        OnNewRootPartial,

        /// <summary>
        /// Enables/disables generation of mermaid-format class diagram via ToString(). Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // ToString = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ToString, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ToString,

        /// <summary>
        /// Enables/disables thread-safe composition object creation. Default: <c>On</c>.
        /// <example>
        /// <code>
        /// // ThreadSafe = Off
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ThreadSafe, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ThreadSafe,

        /// <summary>
        /// Modifier override for Resolve&lt;T&gt;() method. Default: <c>public</c>.
        /// <example>
        /// <code>
        /// // ResolveMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ResolveMethodModifiers,

        /// <summary>
        /// Name override for Resolve&lt;T&gt;() method. Default: <c>Resolve</c>.
        /// <example>
        /// <code>
        /// // ResolveMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ResolveMethodName,

        /// <summary>
        /// Modifier override for Resolve&lt;T&gt;(tag) method. Default: <c>public</c>.
        /// <example>
        /// <code>
        /// // ResolveByTagMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveByTagMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ResolveByTagMethodModifiers,

        /// <summary>
        /// Name override for Resolve&lt;T&gt;(tag) method. Default: <c>Resolve</c>.
        /// <example>
        /// For example
        /// <code>
        /// // ResolveByTagMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveByTagMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ResolveByTagMethodName,

        /// <summary>
        /// Modifier override for Resolve(Type) method. Default: <c>public</c>.
        /// <example>
        /// <code>
        /// // ObjectResolveMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ObjectResolveMethodModifiers,

        /// <summary>
        /// Name override for Resolve(Type) method. Default: <c>Resolve</c>.
        /// <example>
        /// <code>
        /// // ObjectResolveMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ObjectResolveMethodName,

        /// <summary>
        /// Modifier override for Resolve(Type, tag) method. Default: <c>public</c>.
        /// <example>
        /// <code>
        /// // ObjectResolveByTagMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveByTagMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ObjectResolveByTagMethodModifiers,

        /// <summary>
        /// Name override for Resolve(Type, tag) method. Default: <c>Resolve</c>.
        /// <example>
        /// <code>
        /// // ObjectResolveByTagMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveByTagMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        ObjectResolveByTagMethodName,

        /// <summary>
        /// Modifier override for Dispose() method. Default: <c>public</c>.
        /// <example>
        /// <code>
        /// // DisposeMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisposeMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisposeMethodModifiers,

        /// <summary>
        /// Modifier override for DisposeAsync() method. Default: <c>public</c>.
        /// <example>
        /// <code>
        /// // DisposeAsyncMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisposeAsyncMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisposeAsyncMethodModifiers,

        /// <summary>
        /// Enables/disables code formatting (CPU intensive). Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // FormatCode = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.FormatCode, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        FormatCode,

        /// <summary>
        /// Severity level for unimplemented contract errors. Default: <c>Error</c>.
        /// <example>
        /// <code>
        /// // SeverityOfNotImplementedContract = Warning
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.SeverityOfNotImplementedContract, "Warning")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        SeverityOfNotImplementedContract,

        /// <summary>
        /// Enables/disables generated code comments. Default: <c>On</c>.
        /// <example>
        /// <code>
        /// // Comments = Off
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.Comments, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Comments,

        /// <summary>
        /// Enables/disables skipping the default constructor. Default: <c>Off</c> (meaning the default constructor is used when available).
        /// <example>
        /// <code>
        /// // SkipDefaultConstructor = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.UseDefaultConstructor, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        SkipDefaultConstructor,

        /// <summary>
        /// Regex filter for types to skip default constructors. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // SkipDefaultConstructorImplementationTypeNameRegularExpression = Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.SkipDefaultConstructorImplementationTypeNameRegularExpression, "Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        SkipDefaultConstructorImplementationTypeNameRegularExpression,

        /// <summary>
        /// Wildcard filter for types to skip default constructors. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // SkipDefaultConstructorImplementationTypeNameWildcard = *Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.SkipDefaultConstructorImplementationTypeNameWildcard, "*Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        SkipDefaultConstructorImplementationTypeNameWildcard,

        /// <summary>
        /// Regex filter for lifetimes to skip default constructors. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // SkipDefaultConstructorLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.SkipDefaultConstructorLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        SkipDefaultConstructorLifetimeRegularExpression,

        /// <summary>
        /// Wildcard filter for lifetimes to skip default constructors. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // SkipDefaultConstructorLifetimeWildcard = *Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.SkipDefaultConstructorLifetimeWildcard, "*Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        SkipDefaultConstructorLifetimeWildcard,

        /// <summary>
        /// Disables automatic binding when no explicit binding exists. Default: <c>Off</c>.
        /// <example>
        /// <code>
        /// // DisableAutoBinding = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisableAutoBinding,

        /// <summary>
        /// Regex filter for implementation types to disable auto-binding. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // DisableAutoBindingImplementationTypeNameRegularExpression = Dependency
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Hint(Hint.DisableAutoBindingImplementationTypeNameRegularExpression, "Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisableAutoBindingImplementationTypeNameRegularExpression,

        /// <summary>
        /// Wildcard filter for implementation types to disable auto-binding. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // DisableAutoBindingImplementationTypeNameWildcard = *Dependency
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Hint(Hint.DisableAutoBindingImplementationTypeNameWildcard, "*Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisableAutoBindingImplementationTypeNameWildcard,

        /// <summary>
        /// Regex filter for lifetimes to disable auto-binding. Default: <c>.+</c>.
        /// <example>
        /// <code>
        /// // DisableAutoBindingLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Hint(Hint.DisableAutoBindingLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisableAutoBindingLifetimeRegularExpression,

        /// <summary>
        /// Wildcard filter for lifetimes to disable auto-binding. Default: <c>*</c>.
        /// <example>
        /// <code>
        /// // DisableAutoBindingLifetimeWildcard = *Singleton
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        ///
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisableAutoBinding, "Off")
        ///     .Hint(Hint.DisableAutoBindingLifetimeWildcard, "*Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        DisableAutoBindingLifetimeWildcard,
    }

    /// <summary>
    /// Represents a generic type argument attribute. It allows you to create custom generic type argument such as <see cref="TTS"/>, <see cref="TTDictionary{TKey,TValue}"/>, etc.
    /// <example>
    /// <code>
    /// [GenericTypeArgument]
    /// internal interface TTMy: IMy { }
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="IConfiguration.GenericTypeArgumentAttribute{T}"/>
    /// <seealso cref="IConfiguration.GenericTypeArgument{T}"/>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Interface | global::System.AttributeTargets.Struct | global::System.AttributeTargets.Enum)]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal sealed class GenericTypeArgumentAttribute: global::System.Attribute { }
    
    /// <summary>
    /// Specifies injection order priority for constructors, methods, properties, and fields.
    /// While this attribute is part of the DI API, you can implement custom ordering attributes in any namespace.
    /// <example>
    /// For constructors, it defines the sequence of attempts to use a particular constructor to create an object:
    /// <code>
    /// class Service: IService
    /// {
    ///     private readonly string _name;
    ///
    ///     [Ordinal(1)]
    ///     public Service(IDependency dependency) =&gt;
    ///         _name = "with dependency";
    ///
    ///     [Ordinal(0)]
    ///     public Service(string name) =&gt; _name = name;
    /// }
    /// </code>
    ///
    /// For fields, properties and methods, it specifies to perform dependency injection and defines the sequence:
    /// <code>
    /// class Person: IPerson
    /// {
    ///     private readonly string _name = "";
    ///
    ///     [Ordinal(0)]
    ///     public int Id;
    ///
    ///     [Ordinal(1)]
    ///     public string FirstName
    ///     {
    ///         set
    ///         {
    ///             _name = value;
    ///         }
    ///     }
    ///
    ///     public IDependency? Dependency { get; private set; }
    ///
    ///     [Ordinal(2)]
    ///     public void SetDependency(IDependency dependency) =&gt;
    ///         Dependency = dependency;
    /// }
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="DependencyAttribute"/>
    /// <seealso cref="TagAttribute"/>
    /// <seealso cref="TypeAttribute"/>
    [global::System.AttributeUsage(global::System.AttributeTargets.Constructor | global::System.AttributeTargets.Method | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field, AllowMultiple = false)]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal class OrdinalAttribute: global::System.Attribute
    {
        /// <summary>
        /// Initializes an attribute instance with the specified injection priority.
        /// </summary>
        /// <param name="ordinal">Lower values indicate higher priority (0 executes before 1). Default: 0.</param>
        public OrdinalAttribute(int ordinal = 0) { }
    }

    /// <summary>
    /// Represents a tag attribute overriding an injection tag. The tag can be a constant, a type, or a value of an enumerated type.
    /// This attribute is part of the API, but you can use your own attribute at any time, and this allows you to define them in the assembly and namespace you want.
    /// <example>
    /// Sometimes it's important to take control of building a dependency graph. For example, when there are multiple implementations of the same contract. In this case, tags will help:
    /// <code>
    /// interface IDependency { }
    /// 
    ///
    /// class AbcDependency: IDependency { }
    /// 
    ///
    /// class XyzDependency: IDependency { }
    /// 
    ///
    /// class Dependency: IDependency { }
    /// 
    ///
    /// interface IService
    /// {
    ///     IDependency Dependency1 { get; }
    /// 
    ///
    ///     IDependency Dependency2 { get; }
    /// }
    ///
    /// 
    /// class Service: IService
    /// {
    ///     public Service(
    ///         [Tag("Abc")] IDependency dependency1,
    ///         [Tag("Xyz")] IDependency dependency2)
    ///     {
    ///         Dependency1 = dependency1;
    ///         Dependency2 = dependency2;
    ///     }
    ///
    ///     public IDependency Dependency1 { get; }
    ///
    /// 
    ///     public IDependency Dependency2 { get; }
    /// }
    ///
    /// 
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&gt;("Abc").To&lt;AbcDependency&gt;()
    ///     .Bind&lt;IDependency&gt;("Xyz").To&lt;XyzDependency&gt;()
    ///     .Bind&lt;IService&gt;().To&lt;Service&gt;().Root&lt;IService&gt;("Root");
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="DependencyAttribute"/>
    /// <seealso cref="OrdinalAttribute"/>
    /// <seealso cref="TypeAttribute"/>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field, AllowMultiple = false)]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal class TagAttribute: global::System.Attribute
    {
        /// <summary>
        /// Creates an attribute instance.
        /// </summary>
        /// <param name="tag">The injection tag. See also <see cref="IBinding.Tags"/></param>.
        public TagAttribute(object tag) { }
    }

    /// <summary>
    /// The injection type can be defined manually using the <c>Type</c> attribute. This attribute explicitly overrides an injected type, otherwise it would be determined automatically based on the type of the constructor/method, property, or field parameter.
    /// This attribute is part of the API, but you can use your own attribute at any time, and this allows you to define them in the assembly and namespace you want.
    /// <example>
    /// <code>
    /// interface IDependency { }
    /// 
    ///
    /// class AbcDependency: IDependency { }
    ///
    ///
    /// class XyzDependency: IDependency { }
    ///
    ///
    /// interface IService
    /// {
    ///     IDependency Dependency1 { get; }
    ///
    ///     IDependency Dependency2 { get; }
    /// }
    ///
    ///
    /// class Service: IService
    /// {
    ///     public Service(
    ///         [Type(typeof(AbcDependency))] IDependency dependency1,
    ///         [Type(typeof(XyzDependency))] IDependency dependency2)
    ///     {
    ///         Dependency1 = dependency1;
    ///         Dependency2 = dependency2;
    ///     }
    ///
    ///
    ///     public IDependency Dependency1 { get; }
    ///
    ///
    ///     public IDependency Dependency2 { get; }
    /// }
    ///
    ///
    /// DI.Setup("Composition")
    ///     .Bind&lt;IService&gt;().To&lt;Service&gt;().Root&lt;IService&gt;("Root");
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="DependencyAttribute"/>
    /// <seealso cref="TagAttribute"/>
    /// <seealso cref="OrdinalAttribute"/>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field, AllowMultiple = false)]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal class TypeAttribute: global::System.Attribute
    {
        /// <summary>
        /// Creates an attribute instance.
        /// </summary>
        /// <param name="type">The injection type. See also <see cref="IConfiguration.Bind{T}"/> and <see cref="IBinding.Bind{T}"/>.</param>
        public TypeAttribute(global::System.Type type) { }
    }

    /// <summary>
    /// Combines injection tagging and ordering capabilities in a single attribute.
    /// Allows simultaneous specification of both tag and ordinal for dependency injection points.
    /// </summary>
    /// <param name="tag">Identifies the specific dependency variation to inject. See also <see cref="IBinding.Tags"/>.</param>
    /// <param name="ordinal">Determines injection order priority (lower values execute first).</param>
    /// <seealso cref="OrdinalAttribute"/>
    /// <seealso cref="TagAttribute"/>
    [global::System.AttributeUsage(global::System.AttributeTargets.Constructor | global::System.AttributeTargets.Method | global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field)]
    #if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    #endif
    internal class DependencyAttribute: global::System.Attribute
    {
        /// <summary>
        /// Initializes an attribute instance with optional tag and priority.
        /// </summary>
        /// <param name="tag">Identifies a specific dependency variation. See also <see cref="IBinding.Tags"/>.</param>
        /// <param name="ordinal">Injection execution priority (0 = highest priority). Default: 0.</param>
        public DependencyAttribute(object? tag = null, int ordinal = 0) { }
    };

    /// <summary>
    /// Indicates that a property or method can be automatically added as a binding.
    /// <example>
    /// <code>
    /// internal class DependencyProvider
    /// {
    ///     [Bind()]
    ///     public Dependency Dep => new Dependency();
    /// }
    /// </code>
    /// <code>
    /// internal class DependencyProvider
    /// {
    ///     [Bind(typeof(IDependency&lt;TT&gt;), Lifetime.Singleton)]
    ///     public Dependency GetDep&lt;T&gt;() =&gt; new Dependency();
    /// }
    /// </code>
    /// <code>
    /// internal class DependencyProvider
    /// {
    ///     [Bind(typeof(IDependency), Lifetime.PerResolve, "some tag")]
    ///     public Dependency GetDep(int id) => new Dependency(id);
    /// }
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="RootKinds.Exposed"/>
    [global::System.AttributeUsage(global::System.AttributeTargets.Property | global::System.AttributeTargets.Method | global::System.AttributeTargets.Field)]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal class BindAttribute: global::System.Attribute
    {
        /// <summary>
        /// Creates an attribute instance.
        /// </summary>
        public BindAttribute(global::System.Type type = default(global::System.Type), Lifetime lifetime = Lifetime.Transient, params object[] tags) { }
    }

    /// <summary>
    /// Determines how the partial class will be generated. The <see cref="DI.Setup"/> method has an additional argument <c>kind</c>, which defines the type of composition:
    /// <example>
    /// <code>
    /// DI.Setup("BaseComposition", CompositionKind.Internal);
    /// </code>
    /// </example>
    /// </summary>
    /// <seealso cref="DI.Setup"/>
    internal enum CompositionKind
    {
        /// <summary>
        /// This value is used by default. If this value is specified, a normal partial class will be generated.
        /// </summary>
        Public,
        
        /// <summary>
        /// If this value is specified, the class will not be generated, but this setting can be used by other users as a baseline. The API call <see cref="IConfiguration.DependsOn"/> is mandatory.
        /// </summary>
        Internal,
        
        /// <summary>
        /// No partial classes will be created when this value is specified, but this setting is the baseline for all installations in the current project, and the API call <see cref="IConfiguration.DependsOn"/> is not required.
        /// </summary>
        Global
    }

    /// <summary>
    /// Specifies configuration flags for composition root members, controlling their access level, modifiers, and representation.
    /// Flags can be combined to define complex root behaviors.
    /// </summary>
    /// <seealso cref="IConfiguration.Root{T}"/>
    /// <seealso cref="IConfiguration.RootBind{T}"/>
    /// <seealso cref="IConfiguration.Roots{T}"/>
    /// <seealso cref="IConfiguration.Builder{T}"/>
    /// <seealso cref="IConfiguration.Builders{T}"/>
    [global::System.Flags]
    internal enum RootKinds
    {
        /// <summary>
        /// Default configuration: Public access modifier and property representation.
        /// </summary>
        Default = RootKinds.Public | RootKinds.Property,

        /// <summary>
        /// Public access modifier for the composition root.
        /// </summary>
        Public = 1,

        /// <summary>
        /// Internal access modifier for the composition root.
        /// </summary>
        Internal = 1 << 1,

        /// <summary>
        /// Private access modifier for the composition root.
        /// </summary>
        Private = 1 << 2,

        /// <summary>
        /// Represents the composition root as a property.
        /// </summary>
        Property = 1 << 3,

        ///
        /// <summary>
        /// Represents the composition root as a method.
        /// </summary>
        Method = 1 << 4,

        /// <summary>
        /// Defines the composition root as static.
        /// </summary>
        Static = 1 << 5,

        /// <summary>
        /// Defines the composition root as partial.
        /// </summary>
        Partial = 1 << 6,

        /// <summary>
        /// Exposes the root for external binding via attributes.
        /// </summary>
        /// <seealso cref="BindAttribute"/>
        Exposed = 1 << 7,

        /// <summary>
        /// Protected access modifier for the composition root.
        /// </summary>
        Protected = 1 << 8,

        /// <summary>
        /// Applies virtual modifier to enable overriding in derived classes.
        /// </summary>
        Virtual = 1 << 9,

        /// <summary>
        /// Applies override modifier to redefine a base implementation.
        /// </summary>
        Override = 1 << 10,
    }
    
        /// <summary>
    /// Provides standardized tags for dependency binding scenarios, including special tags for unique bindings, type-based identification, and injection targeting.
    /// </summary>
    /// <seealso cref="IConfiguration.Bind{T}"/>
    /// <seealso cref="IBinding.Tags"/>
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal partial class Tag
    {
        private static readonly Tag Shared = new Tag();

        /// <summary>
        /// Enables multiple distinct bindings for the same instance type. Used for collection injection.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;(Tag.Unique).To&lt;Service1&gt;()
        ///     .Bind&lt;IService&gt;(Tag.Unique).To&lt;Service1&gt;()
        ///     .Root&lt;IEnumerable&lt;IService&gt;&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        public static readonly Tag Unique = new Tag();

        /// <summary>
        /// Tags bindings by their implementation type for explicit injection.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;(Tag.Type).To&lt;Service&gt;()
        ///     .Root&lt;IService&gt;("Root", typeof(Service));
        /// </code>
        /// </example>
        /// </summary>
        public static readonly Tag Type = new Tag();

        /// <summary>
        /// Matches any tag during resolution. Used for conditional bindings that accept any tag.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///  DI.Setup(nameof(Composition))
        ///      .Bind&lt;IDependency&gt;(Tag.Any).To(ctx =&gt; new Dependency(ctx.Tag))
        ///      .Bind&lt;IService&gt;().To&lt;Service&gt;()
        /// </code>
        /// </example>
        /// </summary>
        public static readonly Tag Any = new Tag();

        /// <summary>
        /// Creates a tag targeting specific injection sites using member identifiers.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind(Tag.On("MyNamespace.Service.Service:dep"))
        ///         .To&lt;Dependency&gt;()
        ///     .Bind().To&lt;Service&gt;()
        ///     .Root&lt;&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="injectionSites">Member identifiers in format: [namespace].[type].[member][:argument]. Case-sensitive. Wildcards (*, ?) supported. Omit 'global::'.</param>
        public static Tag On(params string[] injectionSites) => Shared;

        /// <summary>
        /// Creates a tag targeting a specific constructor parameter by name.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind(Tag.OnConstructorArg&lt;Service&gt;("dep"))
        ///         .To&lt;Dependency&gt;()
        ///     .Bind().To&lt;Service&gt;()
        ///     .Root&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="argName">Constructor parameter name</param>
        public static Tag OnConstructorArg<T>(string argName) => Shared;

        /// <summary>
        /// Creates a tag targeting a specific field or property by name.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind(Tag.OnMember&lt;Service&gt;("DepProperty"))
        ///         .To&lt;Dependency&gt;()
        ///     .Bind().To&lt;Service&gt;()
        ///     .Root&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="memberName">Field or property name</param>
        public static Tag OnMember<T>(string memberName) => Shared;

        /// <summary>
        /// Creates a tag targeting a specific method parameter by method and argument names.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind(Tag.OnMethodArg&lt;Service&gt;("DoSomething", "state"))
        ///         .To&lt;Dependency&gt;()
        ///     .Bind().To&lt;Service&gt;()
        ///     .Root&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="methodName">Method name</param>
        /// <param name="argName">Parameter name</param>
        public static Tag OnMethodArg<T>(string methodName, string argName) => Shared;
    }

    /// <summary>
    /// Provides well-known names used throughout the dependency injection configuration.
    /// </summary>
    /// <remarks>
    /// These names serve as standardized identifiers for common DI components and behaviors.
    /// </remarks>
    #if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    #endif
    internal partial class Name
    {
    }

    /// <summary>
    /// Represents an owned resource whose lifetime is managed by its owner.
    /// Provides both synchronous and asynchronous disposal capabilities for proper resource cleanup.
    /// </summary>
    /// <seealso cref="Owned"/>
    /// <seealso cref="IConfiguration.Accumulate{T,TAccumulator}"/>
    internal interface IOwned
        : global::System.IDisposable
    #if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
            , global::System.IAsyncDisposable
    #endif
    {
    }

    /// <summary>
    /// Manages lifetime of disposable objects by accumulating them and providing deterministic disposal.
    /// Implements both synchronous and asynchronous disposal patterns for comprehensive resource cleanup.
    /// </summary>
    /// <seealso cref="IOwned"/>
    /// <seealso cref="IConfiguration.Accumulate{T,TAccumulator}"/>
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal sealed partial class Owned: global::System.Collections.Generic.List<object>, global::Pure.DI.IOwned
    {
        private volatile bool _isDisposed;

        /// <inheritdoc />
        public void Dispose()
        {
            // Skip if already disposed
            if (_isDisposed) return;

            _isDisposed = true;
            try
            {
                // Process disposables in reverse order (most recent first)
                for (var i = Count - 1; i >= 0; i--)
                {
                    switch (this[i])
                    {
                        case global::Pure.DI.IOwned _:  // Skip nested owned collections
                            break;

                        case global::System.IDisposable disposableInstance:
                            try
                            {
                                // Perform synchronous disposal
                                disposableInstance.Dispose();
                            }
                            catch (global::System.Exception exception)
                            {
                                // Handle synchronous disposal exceptions
                                OnDisposeException(disposableInstance, exception);
                            }
                            break;

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                        case global::System.IAsyncDisposable asyncDisposableInstance:
                            try
                            {
                                // Handle async disposables in synchronous context
                                var valueTask = asyncDisposableInstance.DisposeAsync();
                                if (!valueTask.IsCompleted)
                                {
                                    // Block until async disposal completes
                                    valueTask.AsTask().Wait();
                                }
                            }
                            catch (global::System.Exception exception)
                            {
                                // Handle asynchronous disposal exceptions
                                OnDisposeAsyncException(asyncDisposableInstance, exception);
                            }
                            break;
#endif
                    }
                }
            }
            finally
            {
                // Clear all references to allow garbage collection
                Clear();
            }
        }

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <inheritdoc />
        public async global::System.Threading.Tasks.ValueTask DisposeAsync()
        {
            // Skip if already disposed
            if (_isDisposed) return;

            _isDisposed = true;
            try
            {
                // Process disposables in reverse order (most recent first)
                for (var i = Count - 1; i >= 0; i--)
                {
                    switch (this[i])
                    {
                        case global::Pure.DI.IOwned _:  // Skip nested owned collections
                            break;

                        case global::System.IAsyncDisposable asyncDisposableInstance:
                            try
                            {
                                // Handle async disposables natively
                                await asyncDisposableInstance.DisposeAsync();
                            }
                            catch (global::System.Exception exception)
                            {
                                // Handle asynchronous disposal exceptions
                                OnDisposeAsyncException(asyncDisposableInstance, exception);
                            }
                            break;

                        case global::System.IDisposable disposableInstance:
                            try
                            {
                                // Handle sync disposables directly
                                disposableInstance.Dispose();
                            }
                            catch (global::System.Exception exception)
                            {
                                // Handle synchronous disposal exceptions
                                OnDisposeException(disposableInstance, exception);
                            }
                            break;
                    }
                }
            }
            finally
            {
                // Clear all references to allow garbage collection
                Clear();
            }
        }
#endif

        /// <summary>
        /// Override this partial method to implement custom exception handling
        /// during synchronous disposal of an <see cref="IDisposable"/> instance.
        /// </summary>
        /// <param name="disposableInstance">The instance that failed disposal</param>
        /// <param name="exception">Exception that occurred during disposal</param>
        /// <typeparam name="T">Concrete type of the disposable instance</typeparam>
        partial void OnDisposeException<T>(T disposableInstance, global::System.Exception exception)
            where T: global::System.IDisposable;

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <summary>
        /// Override this partial method to implement custom exception handling
        /// during asynchronous disposal of an <see cref="IAsyncDisposable"/> instance.
        /// </summary>
        /// <param name="asyncDisposableInstance">The instance that failed disposal</param>
        /// <param name="exception">Exception that occurred during disposal</param>
        /// <typeparam name="T">Concrete type of the disposable instance</typeparam>
        partial void OnDisposeAsyncException<T>(T asyncDisposableInstance, global::System.Exception exception)
            where T: global::System.IAsyncDisposable;
#endif
    }
    
    /// <summary>
    /// Represents an owned resource of type <typeparamref name="T"/> that combines a value with its disposal mechanism.
    /// Provides deterministic lifetime management through both synchronous and asynchronous disposal patterns.
    /// </summary>
    /// <typeparam name="T">The type of the owned value.</typeparam>
    /// <seealso cref="IOwned"/>
    /// <seealso cref="Owned"/>
    /// <seealso cref="IConfiguration.Accumulate{T,TAccumulator}"/>
    [global::System.Diagnostics.DebuggerDisplay("{Value}")]
    [global::System.Diagnostics.DebuggerTypeProxy(typeof(global::Pure.DI.Owned<>.DebugView))]
    internal readonly struct Owned<T>: global::Pure.DI.IOwned
    {
        /// <summary>
        /// The owned value instance.
        /// </summary>
        public readonly T Value;

        private readonly global::Pure.DI.IOwned _owned;

        /// <summary>
        /// Initializes a new owned value with its associated disposal mechanism.
        /// </summary>
        /// <param name="value">The value to be owned and managed.</param>
        /// <param name="owned">The disposal mechanism responsible for cleaning up the owned value.</param>
        public Owned(T value, global::Pure.DI.IOwned owned)
        {
            Value = value;
            _owned = owned;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            _owned.Dispose();
        }

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <inheritdoc />
        public global::System.Threading.Tasks.ValueTask DisposeAsync()
        {
            return _owned.DisposeAsync();
        }
#endif

#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
        private class DebugView
        {
            private readonly global::Pure.DI.Owned<T> _owned;

            public DebugView(global::Pure.DI.Owned<T> owned)
            {
                _owned = owned;
            }

            /// <summary>
            /// The owned value visible in debugger.
            /// </summary>
            public T Value
            {
                get { return _owned.Value; }
            }

            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Collapsed)]
            /// <summary>
            /// The disposal mechanism for the owned value (collapsed in debugger by default).
            /// </summary>
            public global::Pure.DI.IOwned Owned
            {
                get { return _owned._owned; }
            }
        }
    }

    /// <summary>
    /// Defines an API for configuring Dependency Injection bindings.
    /// </summary>
    /// <seealso cref="DI.Setup"/>
    internal interface IConfiguration
    {
        /// <summary>
        /// Starts binding definition for the implementation type itself. Also binds all directly implemented abstract types excluding special system interfaces.
        /// Special system interfaces are excluded from binding:
        /// <list type="bullet">
        /// <item>System.Object</item>
        /// <item>System.Enum</item>
        /// <item>System.MulticastDelegate</item>
        /// <item>System.Delegate</item>
        /// <item>System.Collections.IEnumerable</item>
        /// <item>System.Collections.Generic.IEnumerable&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.ICollection&lt;T&gt;</item>
        /// <item>System.Collections.IEnumerator</item>
        /// <item>System.Collections.Generic.IEnumerator&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IIReadOnlyList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</item>
        /// <item>System.IDisposable</item>
        /// <item>System.IAsyncResult</item>
        /// <item>System.AsyncCallback</item>
        /// </list>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind().To&lt;Service&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind(params object[] tags);

        /// <summary>
        /// Starts binding definition for a specific dependency type.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;().To&lt;Service&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        ///seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2, T3>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2, T3, T4>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <typeparam name="T6">Sixth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <typeparam name="T6">Sixth dependency type to bind.</typeparam>
        /// <typeparam name="T7">Seventh dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <typeparam name="T6">Sixth dependency type to bind.</typeparam>
        /// <typeparam name="T7">Seventh dependency type to bind.</typeparam>
        /// <typeparam name="T8">Eighth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags);

        /// <summary>
        /// Starts binding definition with automatic root creation for a dependency type.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .RootBind&lt;IService&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Dependency type to bind and expose as root.</typeparam>
        /// <param name="name">
        /// Root name template (supports {type}, {TYPE}, {tag} placeholders).
        /// Empty name creates a private root accessible only via Resolve methods.
        /// </param>
        /// <param name="kind">Specifies root accessibility and creation method.</param>
        /// <param name="tags">Tags for binding (first tag used for {tag} placeholder).</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IBinding.To{T}()"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.To{T1,T}()"/>
        /// <seealso cref="IBinding.To{T1,T2,T}()"/>
        /// <seealso cref="IBinding.Tags"/>
        /// <seealso cref="IBinding.As"/>
        IBinding RootBind<T>(string name = "", RootKinds kind = RootKinds.Default, params object[] tags);

        /// <summary>
        /// Specifies base setups to inherit bindings from.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .DependsOn(nameof(CompositionBase));
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="setupNames">Names of base composition setups.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="DI.Setup"/>
        IConfiguration DependsOn(params string[] setupNames);

        /// <summary>
        /// Registers custom generic type markers.
        /// <example>
        /// <code>
        /// [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class | AttributeTargets.Struct)]
        /// class MyGenericTypeArgumentAttribute: Attribute;
        ///
        /// [MyGenericTypeArgument]
        /// interface TTMy;
        ///
        /// DI.Setup("Composition")
        ///     .GenericTypeAttribute&lt;MyGenericTypeArgumentAttribute&gt;()
        ///     .Bind&lt;IDependency&lt;TTMy&gt;&gt;().To&lt;Dependency&lt;TTMy&gt;&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Custom attribute type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="GenericTypeArgumentAttribute"/>
        IConfiguration GenericTypeArgumentAttribute<T>() where T: global::System.Attribute;

        /// <summary>
        /// Registers a custom attribute to override injection types.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .TypeAttribute&lt;MyTypeAttribute&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="typeArgumentPosition">Position of type parameter in attribute constructor (default: 0).</param>
        /// <typeparam name="T">Custom attribute type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Pure.DI.TypeAttribute"/>
        IConfiguration TypeAttribute<T>(int typeArgumentPosition = 0) where T: global::System.Attribute;

        /// <summary>
        /// Registers a custom attribute to override injection tags.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .TagAttribute&lt;MyTagAttribute&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="tagArgumentPosition">Position of tag parameter in attribute constructor (default: 0).</param>
        /// <typeparam name="T">Custom attribute type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Pure.DI.TagAttribute"/>
        IConfiguration TagAttribute<T>(int tagArgumentPosition = 0) where T: global::System.Attribute;

        /// <summary>
        /// Registers a custom attribute to override injection priority.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .OrdinalAttribute&lt;MyOrdinalAttribute&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="ordinalArgumentPosition">Position of ordinal parameter in attribute constructor (default: 0).</param>
        /// <typeparam name="T">Custom attribute type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Pure.DI.OrdinalAttribute"/>
        IConfiguration OrdinalAttribute<T>(int ordinalArgumentPosition = 0) where T: global::System.Attribute;

        /// <summary>
        /// Sets the default lifetime for the following bindings.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .DefaultLifetime(Lifetime.Singleton);
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="lifetime">Default lifetime to apply.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Lifetime"/>
        /// <seealso cref="IBinding.As"/>
        IConfiguration DefaultLifetime(Pure.DI.Lifetime lifetime);

        /// <summary>
        /// Sets the default lifetime for bindings of specific types for the following bindings.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .DefaultLifetime&lt;IMySingleton&gt;(Lifetime.Singleton);
        /// </code>
        /// <code>
        /// DI.Setup("Composition")
        ///     .DefaultLifetime&lt;IMySingleton&gt;(Lifetime.Singleton, "my tag");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="lifetime">Default lifetime to apply.</param>
        /// <param name="tags">Tags specifying which bindings to apply this lifetime to.</param>
        /// <typeparam name="T">Type filter for applicable bindings.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Lifetime"/>
        /// <seealso cref="IBinding.As"/>
        IConfiguration DefaultLifetime<T>(Pure.DI.Lifetime lifetime, params object[] tags);

        /// <summary>
        /// Adds a composition argument to be injected.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Arg&lt;int&gt;("id");
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Argument type.</typeparam>
        /// <param name="name">
        /// Argument name template (supports {type}, {TYPE}, {tag} placeholders).
        /// </param>
        /// <param name="tags">Tags to associate with the argument.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="RootArg{T}"/>
        IConfiguration Arg<T>(string name, params object[] tags);

        /// <summary>
        /// Adds a root argument to be injected.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .RootArg&lt;int&gt;("id");
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Argument type.</typeparam>
        /// <param name="name">
        /// Argument name template (supports {type}, {TYPE}, {tag} placeholders).
        /// </param>
        /// <param name="tags">Tags to associate with the argument.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Arg{T}"/>
        IConfiguration RootArg<T>(string name, params object[] tags);

        /// <summary>
        /// Defines the composition root.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Root&lt;Service&gt;("MyService");
        /// </code>
        /// </example>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Root&lt;Service&gt;("My{type}");
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Root type to expose.</typeparam>
        /// <param name="name">
        /// Root name template (supports {type}, {TYPE}, {tag} placeholders).
        /// Empty name creates the private root accessible only via <c>Resolve</c> methods.
        /// </param>
        /// <param name="tag">Tag to associate with the root.</param>
        /// <param name="kind">Specifies root accessibility and creation method.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="RootBind{T}"/>
        /// <seealso cref="Roots{T}"/>
        IConfiguration Root<T>(string name = "", object tag = null, RootKinds kind = RootKinds.Default);

        /// <summary>
        /// Automatically creates roots for all base type implementations found at the time the method is called.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Roots&lt;IService&gt;();
        /// </code>
        /// </example>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Roots&lt;IService&gt;("Root{type}", filter: "*MyService");
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Base type for auto-root discovery.</typeparam>
        /// <param name="name">
        /// Root name template (supports {type}, {TYPE} placeholders).
        /// Empty name creates private roots accessible only via Resolve methods.
        /// </param>
        /// <param name="kind">Specifies root accessibility and creation method.</param>
        /// <param name="filter">Wildcard pattern to filter types by full name.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Root{T}"/>
        IConfiguration Roots<T>(string name = "", RootKinds kind = RootKinds.Default, string filter = "*");

        /// <summary>
        /// Defines a builder method for initializing instances post-creation.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Builder&lt;Service&gt;("BuildUpMyService");
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Type the builder method applies to.</typeparam>
        /// <param name="name">
        /// Builder method name template (supports {type}, {TYPE} placeholders).
        /// Default: "BuildUp".
        /// </param>
        /// <param name="kind">Specifies builder accessibility.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Builders{T}"/>
        IConfiguration Builder<T>(string name = "BuildUp", RootKinds kind = RootKinds.Default);

        /// <summary>
        /// Automatically creates builders for all discoverable implementations of a base type found at the time the method is called.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Builders&lt;Service&gt;();
        /// </code>
        /// </example>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Builder&lt;Service&gt;("BuildUp");
        /// </code>
        /// </example>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Builder&lt;Service&gt;("BuildUp{type}", filter: "*MyService");
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Base type for builder discovery.</typeparam>
        /// <param name="name">
        /// Builder method name template (supports {type}, {TYPE} placeholders).
        /// Default: "BuildUp".
        /// </param>
        /// <param name="kind">Specifies builder accessibility.</param>
        /// <param name="filter">Wildcard pattern to filter types by full name.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Builder{T}"/>
        IConfiguration Builders<T>(string name = "BuildUp", RootKinds kind = RootKinds.Default, string filter = "*");

        /// <summary>
        /// Configures code generation options.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Resolve, "Off");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="hint">Hint type to configure.</param>
        /// <param name="value">Value to set for the hint.</param>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Pure.DI.Hint"/>
        IConfiguration Hint(Hint hint, string value);

        /// <summary>
        /// Registers an accumulator for collecting instances of specific lifetimes. If no lifetime is specified, it works for all.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Accumulate&lt;IDisposable, MyAccumulator&gt;(Lifetime.Transient);
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="lifetimes">Lifetimes of instances to accumulate.</param>
        /// <typeparam name="T">Type of instances to collect.</typeparam>
        /// <typeparam name="TAccumulator">
        /// Accumulator type (requires parameterless constructor and Add(T) method).
        /// </typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="Pure.DI.Lifetime"/>
        IConfiguration Accumulate<T, TAccumulator>(params Lifetime[] lifetimes)
            where TAccumulator: new();

        /// <summary>
        /// Defines a generic type marker for generic bindings.
        /// <example>
        /// <code>
        /// interface TTMy;
        ///
        /// DI.Setup("Composition")
        ///     .GenericTypeArgument&lt;TTMy&gt;()
        ///     .Bind&lt;IDependency&lt;TTMy&gt;&gt;().To&lt;Dependency&lt;TTMy&gt;&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Generic type marker.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="GenericTypeArgumentAttribute{T}"/>
        IConfiguration GenericTypeArgument<T>();
    }

    /// <summary>
    /// Defines the API for configuring dependency bindings in the composition.
    /// </summary>
    internal interface IBinding
    {
        /// <summary>
        /// Starts binding definition for the implementation type itself. Also binds all directly implemented abstract types excluding special system interfaces.
        /// Special system interfaces are excluded from binding:
        /// <list type="bullet">
        /// <item>System.Object</item>
        /// <item>System.Enum</item>
        /// <item>System.MulticastDelegate</item>
        /// <item>System.Delegate</item>
        /// <item>System.Collections.IEnumerable</item>
        /// <item>System.Collections.Generic.IEnumerable&lt;T&gt;</item>
        /// <item>System.Collections.Generic.Iist&lt;T&gt;</item>
        /// <item>System.Collections.Generic.ICollection&lt;T&gt;</item>
        /// <item>System.Collections.IEnumerator</item>
        /// <item>System.Collections.Generic.IEnumerator&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IIReadOnlyList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</item>
        /// <item>System.IDisposable</item>
        /// <item>System.IAsyncResult</item>
        /// <item>System.AsyncCallback</item>
        /// </list>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind().To&lt;Service&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="tags">Optional tags to associate with this binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind(params object[] tags);

        /// <summary>
        /// Starts binding definition for a specific dependency type.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Dependency type to bind. Supports type markers like <see cref="TT"/> and <see cref="TTList{T}"/>.</typeparam>
        /// <param name="tags">Optional tags to associate with this binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2, T3>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2, T3, T4>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <typeparam name="T6">Sixth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <typeparam name="T6">Sixth dependency type to bind.</typeparam>
        /// <typeparam name="T7">Seventh dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags);

        /// <summary>
        /// Starts binding definition for multiple dependency types simultaneously.
        /// See <see cref="Bind{T}"/> for detailed usage.
        /// </summary>
        /// <typeparam name="T1">First dependency type to bind.</typeparam>
        /// <typeparam name="T2">Second dependency type to bind.</typeparam>
        /// <typeparam name="T3">Third dependency type to bind.</typeparam>
        /// <typeparam name="T4">Fourth dependency type to bind.</typeparam>
        /// <typeparam name="T5">Fifth dependency type to bind.</typeparam>
        /// <typeparam name="T6">Sixth dependency type to bind.</typeparam>
        /// <typeparam name="T7">Seventh dependency type to bind.</typeparam>
        /// <typeparam name="T8">Eighth dependency type to bind.</typeparam>
        /// <param name="tags">Optional tags to associate with these bindings.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags);

        /// <summary>
        /// Specifies the lifetime scope for the binding.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.Singleton).To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="lifetime">Lifetime scope for the binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        IBinding As(Pure.DI.Lifetime lifetime);

        /// <summary>
        /// Specifies binding tags to differentiate between multiple implementations of the same interface.
        /// <example>
        /// <code>
        /// interface IDependency { }
        ///
        /// class AbcDependency: IDependency { }
        ///
        /// class XyzDependency: IDependency { }
        ///
        /// class Dependency: IDependency { }
        ///
        /// interface IService
        /// {
        ///     IDependency Dependency1 { get; }
        ///     IDependency Dependency2 { get; }
        /// }
        ///
        /// class Service: IService
        /// {
        ///     public Service(
        ///         [Tag("Abc")] IDependency dependency1,
        ///         [Tag("Xyz")] IDependency dependency2)
        ///     {
        ///         Dependency1 = dependency1;
        ///         Dependency2 = dependency2;
        ///     }
        ///
        ///     public IDependency Dependency1 { get; }
        ///     public IDependency Dependency2 { get; }
        /// }
        ///
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().Tags("Abc").To&lt;AbcDependency&gt;()
        ///     .Bind&lt;IDependency&gt;().Tags("Xyz").To&lt;XyzDependency&gt;()
        ///     .Bind&lt;IService&gt;().To&lt;Service&gt;().Root&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="tags">Tags to associate with this binding.</param>
        /// <returns>Binding configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="As"/>
        IBinding Tags(params object[] tags);

        /// <summary>
        /// Specifies the implementation type for the binding.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        /// <typeparam name="T">Implementation type. Supports generic type markers.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T>();

        /// <summary>
        /// Specifies a factory method to create the implementation instance.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(_ =&gt;
        ///     {
        ///         var service = new Service("My Service");
        ///         service.Initialize();
        ///         return service;
        ///     })
        ///
        /// // Another example:
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;IDependency&gt;(out var dependency);
        ///         return new Service(dependency);
        ///     })
        ///
        /// // And another example:
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         // Builds up an instance with all necessary dependencies
        ///         ctx.Inject&lt;Service&gt;(out var service);
        ///         service.Initialize();
        ///         return service;
        ///     })
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="factory">Factory method to create and initialize the instance.</param>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="To{T1,T}()"/>
        /// <seealso cref="To{T1,T2,T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        /// <remarks>
        /// This method is useful for creating and initializing an instance manually.
        /// At the compilation stage, the set of dependencies that the object to be created needs is determined.
        /// In most cases, this happens automatically, according to the set of constructors and their arguments, and does not require additional customization efforts.
        /// But sometimes it is necessary to manually create and/or initialize an object.
        /// There are scenarios where manual control over the creation process is required, such as
        /// <list type="bullet">
        /// <item>when additional initialization logic is needed</item>
        /// <item>when complex construction steps are required</item>
        /// <item>when specific object states need to be set during creation</item>
        /// </list>
        /// </remarks>
        IConfiguration To<T>(global::System.Func<IContext, T> factory);

        /// <summary>
        /// Specifies a source code statement to create the implementation.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;int&gt;().To&lt;int&gt;("dependencyId")
        ///     .Bind&lt;Func&lt;int, IDependency&gt;&gt;()
        ///         .To&lt;Func&lt;int, IDependency&gt;&gt;(ctx =&gt;
        ///             dependencyId =&gt;
        ///             {
        ///                 ctx.Inject&lt;Dependency&gt;(out var dependency);
        ///                 return dependency;
        ///             });
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="sourceCodeStatement">Source code expression to create the instance.</param>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        IConfiguration To<T>(string sourceCodeStatement);

        /// <summary>
        /// Specifies a simplified factory method with dependency parameters.
        /// <example>
        /// <code>
        /// DI.Setup(nameof(Composition))
        ///     .Bind&lt;IDependency&gt;().To((
        ///         Dependency dependency) =&gt;
        ///     {
        ///         dependency.Initialize();
        ///         return dependency;
        ///     });
        ///
        /// // Variant using TagAttribute:
        /// DI.Setup(nameof(Composition))
        ///     .Bind&lt;IDependency&gt;().To((
        ///         [Tag("some tag")] Dependency dependency) =&gt;
        ///     {
        ///         dependency.Initialize();
        ///         return dependency;
        ///     });
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T>(global::System.Func<T1, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// <example>
        /// <code>
        /// DI.Setup(nameof(Composition))
        ///     .Bind&lt;IDependency&gt;().To((
        ///         Dependency dependency,
        ///         DateTimeOffset time) =&gt;
        ///     {
        ///         dependency.Initialize(time);
        ///         return dependency;
        ///     });
        ///
        /// // Variant using TagAttribute:
        /// DI.Setup(nameof(Composition))
        ///     .Bind("now datetime").To(_ =&gt; DateTimeOffset.Now)
        ///     .Bind&lt;IDependency&gt;().To((
        ///         Dependency dependency,
        ///         [Tag("now datetime")] DateTimeOffset time) =&gt;
        ///     {
        ///         dependency.Initialize(time);
        ///         return dependency;
        ///     });
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of second dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T>(global::System.Func<T1, T2, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of the second dependency parameter.</typeparam>
        /// <typeparam name="T3">Type of the third dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T3, T>(global::System.Func<T1, T2, T3, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of the second dependency parameter.</typeparam>
        /// <typeparam name="T3">Type of the third dependency parameter.</typeparam>
        /// <typeparam name="T4">Type of the fourth dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T3, T4, T>(global::System.Func<T1, T2, T3, T4, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of the second dependency parameter.</typeparam>
        /// <typeparam name="T3">Type of the third dependency parameter.</typeparam>
        /// <typeparam name="T4">Type of the fourth dependency parameter.</typeparam>
        /// <typeparam name="T5">Type of the fifth dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T3, T4, T5, T>(global::System.Func<T1, T2, T3, T4, T5, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of the second dependency parameter.</typeparam>
        /// <typeparam name="T3">Type of the third dependency parameter.</typeparam>
        /// <typeparam name="T4">Type of the fourth dependency parameter.</typeparam>
        /// <typeparam name="T5">Type of the fifth dependency parameter.</typeparam>
        /// <typeparam name="T6">Type of the sixth dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T3, T4, T5, T6, T>(global::System.Func<T1, T2, T3, T4, T5, T6, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of the second dependency parameter.</typeparam>
        /// <typeparam name="T3">Type of the third dependency parameter.</typeparam>
        /// <typeparam name="T4">Type of the fourth dependency parameter.</typeparam>
        /// <typeparam name="T5">Type of the fifth dependency parameter.</typeparam>
        /// <typeparam name="T6">Type of the sixth dependency parameter.</typeparam>
        /// <typeparam name="T7">Type of the seventh dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T3, T4, T5, T6, T7, T>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T> factory);

        /// <summary>
        /// Specifies a simplified factory method with multiple dependency parameters.
        /// </summary>
        /// <param name="factory">Factory method with injected dependencies.</param>
        /// <typeparam name="T1">Type of the first dependency parameter.</typeparam>
        /// <typeparam name="T2">Type of the second dependency parameter.</typeparam>
        /// <typeparam name="T3">Type of the third dependency parameter.</typeparam>
        /// <typeparam name="T4">Type of the fourth dependency parameter.</typeparam>
        /// <typeparam name="T5">Type of the fifth dependency parameter.</typeparam>
        /// <typeparam name="T6">Type of the sixth dependency parameter.</typeparam>
        /// <typeparam name="T7">Type of the seventh dependency parameter.</typeparam>
        /// <typeparam name="T8">Type of the eighth dependency parameter.</typeparam>
        /// <typeparam name="T">Implementation type.</typeparam>
        /// <returns>Configuration interface for method chaining.</returns>
        /// <seealso cref="IConfiguration.Bind{T}"/>
        /// <seealso cref="To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="To{T}()"/>
        /// <seealso cref="Tags"/>
        /// <seealso cref="As"/>
        IConfiguration To<T1, T2, T3, T4, T5, T6, T7, T8, T>(global::System.Func<T1, T2, T3, T4, T5, T6, T7, T8, T> factory);
    }

    /// <summary>
    /// Injection context. Cannot be used outside the binding setup.
    /// </summary>
    internal interface IContext
    {
        /// <summary>
        /// The tag that was used to inject the current object in the object graph. Cannot be used outside the binding setup. See also <see cref="IBinding.Tags"/>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;Lazy&lt;TT&gt;&gt;()
        ///     .To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;Func&lt;TT&gt;&gt;(ctx.Tag, out var func);
        ///         return new Lazy&lt;TT&gt;(func, false);
        ///     };
        /// </code>
        /// </example>
        /// </summary>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// <seealso cref="IBinding.Tags"/>
        object Tag { get; }

        /// <summary>
        /// The chain of consumer types for which an instance is created, from the immediate consumer down to the composition type. Cannot be used outside the binding setup. Guaranteed to contain at least one element.
        /// <example>
        /// <code>
        /// var box = new Composition().Box;
        /// // Output: ShroedingersCat, CardboardBox`1, Composition
        ///
        /// static void Setup() =&gt;
        ///     DI.Setup(nameof(Composition))
        ///     .Bind().To(ctx =&gt; new Log(ctx.ConsumerTypes))
        ///     .Bind().To&lt;ShroedingersCat&gt;()
        ///     .Bind().To&lt;CardboardBox&lt;TT&gt;&gt;()
        ///     .Root&lt;CardboardBox&lt;ShroedingersCat&gt;&gt;(&quot;Box&quot;);
        ///
        /// public class Log
        /// {
        ///     public Log(Type[] types) =&gt;
        ///         Console.WriteLine(string.Join(&quot;, &quot;, types.Select(type =&gt; type.Name)));
        /// }
        ///
        /// public record CardboardBox&lt;T&gt;(T Content);
        ///
        /// public record ShroedingersCat(Log log);
        /// </code>
        /// </example>
        /// </summary>
        /// <seealso cref="IContext.ConsumerType"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        Type[] ConsumerTypes { get; }

        /// <summary>
        /// The immediate consumer type for which the instance is created. Cannot be used outside the binding setup.
        /// <example>
        /// <code>
        /// var box = new Composition().Box;
        /// // Output: ShroedingersCat
        ///
        /// static void Setup() =&gt;
        ///     DI.Setup(nameof(Composition))
        ///     .Bind().To(ctx =&gt; new Log(ctx.ConsumerType))
        ///     .Bind().To&lt;ShroedingersCat&gt;()
        ///     .Bind().To&lt;CardboardBox&lt;TT&gt;&gt;()
        ///     .Root&lt;CardboardBox&lt;ShroedingersCat&gt;&gt;(&quot;Box&quot;);
        ///
        /// public class Log
        /// {
        ///     public Log(Type type) =&gt;
        ///         Console.WriteLine(type.Name);
        /// }
        ///
        /// public record CardboardBox&lt;T&gt;(T Content);
        ///
        /// public record ShroedingersCat(Log log);
        /// </code>
        /// </example>
        /// </summary>
        /// <seealso cref="IContext.ConsumerTypes"/>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        Type ConsumerType { get; }

        /// <summary>
        /// Injects an instance of type <c>T</c>. Cannot be used outside the binding setup.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;IDependency&gt;(out var dependency);
        ///         return new Service(dependency);
        ///     })
        /// </code>
        /// <br/>
        /// and another example:<br/>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         // Builds up an instance with all necessary dependencies
        ///         ctx.Inject&lt;Service&gt;(out var service);
        ///
        ///         service.Initialize();
        ///         return service;
        ///     })
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="value">Injectable instance.</param>.
        /// <typeparam name="T">Instance type.</typeparam>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        void Inject<T>(out T value);

        /// <summary>
        /// Injects an instance of type <c>T</c> marked with a tag. Cannot be used outside the binding setup.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;IDependency&gt;("MyTag", out var dependency);
        ///         return new Service(dependency);
        ///     })
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="tag">The injection tag. See also <see cref="IBinding.Tags"/></param>.
        /// <param name="value">Injectable instance.</param>.
        /// <typeparam name="T">Instance type.</typeparam>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        void Inject<T>(object tag, out T value);

        /// <summary>
        /// Builds up of an existing object. In other words, injects the necessary dependencies via methods, properties, or fields into an existing object. Cannot be used outside the binding setup.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         var service = new Service();
        ///         // Initialize an instance with all necessary dependencies
        ///         ctx.BuildUp(service);
        ///         return service;
        ///     })
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="value">An existing object for which the injection(s) is to be performed.</param>
        /// <typeparam name="T">Object type.</typeparam>
        /// <seealso cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        void BuildUp<T>(T value);

        /// <summary>
        /// Overrides the binding with the specified value. Cannot be used outside the binding setup.
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind().To&lt;Func&lt;int, int, IDependency&gt;&gt;(ctx =&gt;
        ///         (dependencyId, subId) =>
        ///         {
        ///             // Overrides with a lambda argument
        ///             ctx.Override(dependencyId);
        ///             // Overrides with tag using lambda argument
        ///             ctx.Override(subId, "sub");
        ///             // Overrides with some value
        ///             ctx.Override($"Dep {dependencyId} {subId}");
        ///             // Overrides with injected value
        ///             ctx.Inject(Tag.Red, out Color red);
        ///             ctx.Override(red);
        ///             ctx.Inject&lt;Dependency&gt;(out var dependency);
        ///             return dependency;
        ///         })
        /// </code>
        /// Overrides uses a shared state to override values. And if this code is supposed to run in multiple threads at once, then you need to ensure their synchronization, for example
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind().To&lt;Func&lt;int, int, IDependency&gt;&gt;(ctx =&gt;
        ///         (dependencyId, subId) =>
        ///         {
        ///             // Get composition sync root object
        ///             ctx.Inject(Tag.SyncRoot, out Lock lockObject);
        ///             lock(lockObject)
        ///             {
        ///                 // Overrides with a lambda argument
        ///                 ctx.Override(dependencyId);
        ///                 // Overrides with tag using lambda argument
        ///                 ctx.Override(subId, "sub");
        ///                 // Overrides with some value
        ///                 ctx.Override($"Dep {dependencyId} {subId}");
        ///                 // Overrides with injected value
        ///                 ctx.Inject(Tag.Red, out Color red);
        ///                 ctx.Override(red);
        ///                 ctx.Inject&lt;Dependency&gt;(out var dependency);
        ///                 return dependency;
        ///             }
        ///         })
        /// </code>
        /// An alternative to synchronizing thread yourself is to use types like <see cref="Func{TArg1,TArg2,TResult}">this</see>. There, threads synchronization is performed automatically.
        /// </summary>
        /// <param name="value">The object that will be used to override a binding.</param>
        /// <typeparam name="T">Object type that will be used to override a binding.</typeparam>
        /// <param name="tags">Injection tags that will be used to override a binding. See also <see cref="IBinding.Tags"/></param>.
        /// <seealso cref="IBinding.To{T}(System.Func{TArg1,T})"/>
        void Override<T>(T value, params object[] tags);
    }
    
    /// <summary>
    /// An API for a Dependency Injection setup.
    /// </summary>
    /// <seealso cref="Setup"/>
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal static class DI
    {
        private static readonly Configuration SharedConfiguration = new Configuration();

        /// <summary>
        /// Begins the definitions of the Dependency Injection setup chain.
        /// <example>
        /// <code>
        /// interface IDependency;
        ///
        /// 
        /// class Dependency: IDependency;
        ///
        /// 
        /// interface IService;
        ///
        /// 
        /// class Service(IDependency dependency): IService;
        ///
        /// 
        /// DI.Setup("Composition")
        ///   .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;()
        ///   .Bind&lt;IService&gt;().To&lt;Service&gt;()
        ///   .Root&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="compositionTypeName">An optional argument specifying the partial class name to generate.</param>
        /// <param name="kind">An optional argument specifying the kind of setup. Please <see cref="Pure.DI.CompositionKind"/> for details. It defaults to <c>Public</c>.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
        internal static IConfiguration Setup(string compositionTypeName = "", CompositionKind kind = CompositionKind.Public)
        {
            return SharedConfiguration;
        }

#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
        [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
        private sealed class Configuration: IConfiguration, IBinding
        {
            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2, T3>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2, T3, T4>(params object[] tags)
            {
                return this;
            }
            
            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding RootBind<T>(string name, RootKinds kind, params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration DependsOn(params string[] setupNames)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration GenericTypeArgumentAttribute<T>()
                where T: global::System.Attribute
            {
                return this;
            }
            
            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration TypeAttribute<T>(int typeArgumentPosition)
                where T: global::System.Attribute
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration TagAttribute<T>(int tagArgumentPosition)
                where T: global::System.Attribute
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration OrdinalAttribute<T>(int ordinalArgumentPosition)
                where T: global::System.Attribute
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration DefaultLifetime(Pure.DI.Lifetime lifetime)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration DefaultLifetime<T>(Lifetime lifetime, params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Arg<T>(string name, params object[] tags)
            {
                return this;
            }
            
            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration RootArg<T>(string name, params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Root<T>(string name, object tag, RootKinds rootKind)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Roots<T>(string name, RootKinds kind, string filter)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Builder<T>(string name, RootKinds kind)
            {
                return this;
            }
            
            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Builders<T>(string name, RootKinds kind, string filter)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Hint(Hint hint, string value)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration Accumulate<T, TAccumulator>(params Lifetime[] lifetimes)
                where TAccumulator: new()
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration GenericTypeArgument<T>()
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding As(Pure.DI.Lifetime lifetime)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IBinding Tags(params object[] tags)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T>()
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T>(global::System.Func<IContext, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T>(string sourceCodeStatement)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T>(global::System.Func<T1, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T>(global::System.Func<T1, T2, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T3, T>(global::System.Func<T1, T2, T3, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T3, T4, T>(Func<T1, T2, T3, T4, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T3, T4, T5, T>(Func<T1, T2, T3, T4, T5, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T3, T4, T5, T6, T>(Func<T1, T2, T3, T4, T5, T6, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T3, T4, T5, T6, T7, T>(Func<T1, T2, T3, T4, T5, T6, T7, T> factory)
            {
                return this;
            }

            /// <inheritdoc />
            [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
            public IConfiguration To<T1, T2, T3, T4, T5, T6, T7, T8, T>(Func<T1, T2, T3, T4, T5, T6, T7, T8, T> factory)
            {
                return this;
            }
        }
    }
    
    /// <summary>
    /// For internal use.
    /// </summary>
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
    internal struct Pair<TValue>
    {
        public readonly global::System.Type Key;
        public readonly TValue Value;

        public Pair(global::System.Type key, TValue value)
        {
            Key = key;
            Value = value;
        }
    }
    
    /// <summary>
    /// For internal use. 
    /// </summary>
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal static class Buckets<TValue>
    {
        [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)256)]
        public static uint GetDivisor(uint count)
        {
            return count < 2 ? count : count << 1;
        }

        public static Pair<TValue>[] Create(
            uint divisor,
            out uint bucketSize,
            Pair<TValue>[] pairs)
        {
            bucketSize = 0;
#if  NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
            global::System.Span<uint> bucketSizes = divisor < 0x1000 ? stackalloc uint[(int)divisor] : new uint[divisor];
#else
            var bucketSizes = new uint[divisor];
#endif
            for (var i = 0; i < pairs.Length; i++)
            {
                var bucket = (int)(((uint)global::System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(pairs[i].Key)) % divisor);
                ref var size = ref bucketSizes[bucket];
                if (++size > bucketSize)
                {
                    bucketSize = size;
                }
            }
            
            var buckets = new Pair<TValue>[divisor * bucketSize];
            for (var i = 0; i < pairs.Length; i++)
            {
                ref var pair = ref pairs[i];
                var bucket = (int)(((uint)global::System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(pair.Key)) % divisor);
                ref var index = ref bucketSizes[bucket++];
                buckets[bucket * bucketSize - index] = pair;
                index--;
            }
            
            return buckets;
        }
    }

    /// <summary>
    /// Represents an abstract dependency resolver interface responsible for resolving composition roots from composite objects. The resolver is designed to handle both generic resolution and tagged resolution, allowing for flexible dependency management in complex applications.
    /// </summary>
    /// <typeparam name="TComposite">
    /// The type of the composite object that contains the dependencies to be resolved.
    /// </typeparam>
    /// <typeparam name="T">
    /// The type of the composition root that will be resolved. The composition root
    /// represents the main entry point or service that the resolver will provide.
    /// </typeparam>
    /// <seealso cref="DI.Setup"/>
    internal interface IResolver<TComposite, out T>
    {
        /// <summary>
        /// Resolves the composition root from the provided composite object using
        /// the default resolution strategy.
        ///
        /// This method is used for straightforward dependency resolution where a
        /// single implementation of the composition root is expected.
        /// </summary>
        /// <param name="composite">
        /// The composite object containing the dependencies required for resolution.
        /// </param>
        /// <returns>
        /// The resolved composition root of type <typeparamref name="T"/>. If the resolution fails, an <see cref="CannotResolveException"/> exception should be thrown.
        /// </returns>
        /// <exception cref="CannotResolveException">
        /// Thrown when the composition root cannot be resolved from the provided composite.
        /// </exception>
        /// <seealso cref="DI.Setup"/>
        T Resolve(TComposite composite);
        
        /// <summary>
        /// Resolves the composition root from the provided composite object using
        /// a specific tag to identify the desired implementation.
        ///
        /// This method is useful when multiple implementations of the same composition
        /// root exist and need to be differentiated by a tag.
        /// </summary>
        /// <param name="composite">
        /// The composite object containing the dependencies required for resolution.
        /// </param>
        /// <param name="tag">
        /// The tag used to identify the specific implementation of the composition root.
        /// The tag can be any object that uniquely identifies the desired implementation.
        /// </param>
        /// <returns>
        /// The resolved composition root of type <typeparamref name="T"/> that matches the specified tag.
        /// </returns>
        /// <exception cref="CannotResolveException">
        /// Thrown when no matching implementation is found for the specified tag.
        /// </exception>
        /// <seealso cref="DI.Setup"/>
        T ResolveByTag(TComposite composite, object tag);
    }

    /// <summary>
    /// Represents an exception thrown when a required composition root cannot be resolved.
    /// </summary>
#if NETSTANDARD2_0_OR_GREATER
    [global::System.Serializable]
#endif
    internal class CannotResolveException: global::System.InvalidOperationException
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CannotResolveException"/> class with a specified error message, type, and optional tag describing the resolution failure.
        /// </summary>
        /// <param name="message">
        /// A user-friendly message that describes the error that occurred during the
        /// resolution process. The message should be clear and informative, providing
        /// enough context to understand the nature of the failure.
        /// </param>
        /// <param name="type">
        /// The <see cref="Type"/> used to resolve a composition root.
        /// </param>
        /// <param name="tag">
        /// The tag used to resolve a composition root.
        /// </param>
        public CannotResolveException(string message, global::System.Type type, object? tag)
            : base(message)
        {
            Type = type;
            Tag = tag;
        }

        /// <summary>
        /// Gets the type used to resolve a composition root.
        /// </summary>
        public Type Type { get; }

        /// <summary>
        /// Gets the tag used to resolve a composition root.
        /// </summary>
        public object? Tag { get; }
    }
}
#pragma warning restore
#endif
