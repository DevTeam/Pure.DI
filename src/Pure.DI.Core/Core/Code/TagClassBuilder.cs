// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable UnusedVariable
namespace Pure.DI.Core.Code;

using static LinesExtensions;

sealed class TagClassBuilder(
    IInformation information,
    ISmartTags smartTags,
    IFormatter formatter,
    IComments comments,
    ITypes types,
    CancellationToken cancellationToken)
    : IBuilder<TagContext, IEnumerable<TagCode>>
{
    private static readonly Dictionary<SmartTagKind, SmartTagInfo> Info = new()
    {
        {
            SmartTagKind.Tag,
            new SmartTagInfo(
                nameof(Tag),
                [
                    "Shared",
                    nameof(Tag.Unique),
                    nameof(Tag.Type),
                    nameof(Tag.Any),
                    nameof(Tag.On),
                    nameof(Tag.OnConstructorArg),
                    nameof(Tag.OnMember)
                ])
        },
        { SmartTagKind.Name, new SmartTagInfo(nameof(Name), []) }
    };

    public IEnumerable<TagCode> Build(TagContext tagContext)
    {
        var tagToDependencies = (
                from composition in tagContext.Compositions
                from dependency in composition.Source.Graph.Edges
                let tag = dependency.Injection.Tag as string
                where tag is not null
                group dependency by (tag: tag!, composition)
                into groupsByTagAndComposition
                group groupsByTagAndComposition by groupsByTagAndComposition.Key.tag)
            .ToDictionary(
                i => i.Key,
                i => i.Select(j => (
                    j.Key.composition,
                    dependencies: j
                        .Select(k => (
                            tag: comments.Escape(k.Injection.Tag != null && k.Injection.Tag is not MdTagOnSites ? $"({k.Injection.Tag})" : ""),
                            target: formatter.FormatRef(k.Target.Type),
                            injectin: types.TypeEquals(k.Injection.Type, k.Source.Type) ? "" : formatter.FormatRef(k.Injection.Type),
                            source: formatter.FormatRef(k.Source.Type),
                            sourceLifetime: formatter.FormatRef(k.Source.Lifetime)))
                        .Select(k => $"/// <item>{k.target} &lt;-- {k.injectin}{k.tag} -- {k.source} as {k.sourceLifetime}</item>")
                        .Distinct()
                        .OrderBy(k => k))));

        if (TryBuildTagCode(SmartTagKind.Tag, tagToDependencies, AddTagComments, out var tagCode))
        {
            yield return (TagCode)tagCode;
        }

        if (TryBuildTagCode(SmartTagKind.Name, Unit.Shared, DoesNotAddComments, out var nameCode))
        {
            yield return (TagCode)nameCode;
        }
    }

    private bool TryBuildTagCode<TContext>(
        SmartTagKind kind,
        TContext context,
        Commenter<TContext> commenter,
        [NotNullWhen(true)] out TagCode? tagCode)
    {
        if (!Info.TryGetValue(kind, out var info))
        {
            tagCode = null;
            return false;
        }

        cancellationToken.ThrowIfCancellationRequested();

        var tags = smartTags.Get(kind).Where(i => !info.Exclusions.Contains(i.Name)).ToList();
        if (tags.Count == 0)
        {
            tagCode = null;
            return false;
        }

        var code = new Lines();
        code.AppendLine("// <auto-generated/>");
        code.AppendLine($"// by {information.Description}");
        code.AppendLine($"namespace {Names.GeneratorName}");
        using (code.CreateBlock())
        {
            code.AppendLine($"internal partial class {info.ClassName}");
            using (code.CreateBlock())
            {
                var isFirst = true;
                foreach (var tag in tags)
                {
                    if (isFirst)
                    {
                        isFirst = false;
                    }
                    else
                    {
                        code.AppendLine();
                    }

                    commenter(tag, code, context);
                    code.AppendLine($"public const string {tag.Name} = {tag.Name.ValueToString()};");
                }
            }
        }

        tagCode = new TagCode(info.ClassName, code);
        return true;
    }

    private delegate void Commenter<in TContext>(SmartTag tag, Lines code, TContext context);

    private void AddTagComments(
        SmartTag tag,
        Lines code,
        Dictionary<string, IEnumerable<(CompositionCode composition, IOrderedEnumerable<string> dependencies)>> tagToDependencies)
    {
        code.AppendLine("/// <summary>");
        code.AppendLine($"/// Atomically generated smart tag with value {comments.Escape(tag.Name.ValueToString())}.");
        if (tagToDependencies.TryGetValue(tag.Name, out var dependenciesByComposition))
        {
            code.AppendLine("/// It's used for:");
            code.AppendLine("/// <br/>");
            foreach (var (composition, dependencies) in dependenciesByComposition)
            {
                code.AppendLine("/// <br/>");
                code.AppendLine($"/// class {formatter.FormatRef(composition.Source.Source.Name.FullName)}");
                code.AppendLine("/// <list type=\"number\">");
                foreach (var dependency in dependencies)
                {
                    code.AppendLine(dependency);
                }

                code.AppendLine("/// </list>");
            }
        }

        code.AppendLine("/// </summary>");
    }

    private static void DoesNotAddComments(SmartTag tag, Lines code, Unit context)
    {
    }

    private readonly record struct SmartTagInfo(string ClassName, HashSet<string> Exclusions);
}