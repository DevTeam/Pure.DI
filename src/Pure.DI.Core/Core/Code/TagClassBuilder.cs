// ReSharper disable ClassNeverInstantiated.Global
// ReSharper disable UnusedVariable
namespace Pure.DI.Core.Code;

sealed class TagClassBuilder(
    IInformation information,
    ISmartTags smartTags,
    IFormatter formatter,
    IComments comments,
    ITypes types,
    CancellationToken cancellationToken)
    : IBuilder<TagContext, TagCode>
{
    public TagCode Build(TagContext tagContext)
    {
        var tagToDependencies = (
                from composition in tagContext.Compositions
                from dependency in composition.Source.Graph.Edges
                let tag = dependency.Injection.Tag as string
                where tag is not null
                group dependency by (tag: tag!, composition)
                into groupsByTagAndComposition
                group groupsByTagAndComposition by groupsByTagAndComposition.Key.tag)
            .ToDictionary(
                i => i.Key,
                i => i.Select(j => (
                    j.Key.composition,
                    dependencies: j
                        .Select(k => (
                            tag: comments.Escape(k.Injection.Tag != null && k.Injection.Tag is not MdTagOnSites ? $"({k.Injection.Tag})" : ""),
                            target: formatter.FormatRef(k.Target.Type),
                            injectin: types.TypeEquals(k.Injection.Type, k.Source.Type) ? "" : formatter.FormatRef(k.Injection.Type),
                            source: formatter.FormatRef(k.Source.Type),
                            sourceLifetime: formatter.FormatRef(k.Source.Lifetime)))
                        .Select(k => $"/// <item>{k.target} &lt;-- {k.injectin}{k.tag} -- {k.source} as {k.sourceLifetime}</item>")
                        .Distinct()
                        .OrderBy(k => k))));

        cancellationToken.ThrowIfCancellationRequested();

        var code = new LinesBuilder();
        var tags = smartTags.GetAll();
        code.AppendLine("// <auto-generated/>");
        code.AppendLine($"// by {information.Description}");

        code.AppendLine($"namespace {Names.GeneratorName}");
        code.AppendLine("{");
        using (code.Indent())
        {
            code.AppendLine($"internal partial class {nameof(Tag)}");
            code.AppendLine("{");
            using (code.Indent())
            {
                var isFirst = true;
                foreach (var tag in tags)
                {
                    if (isFirst)
                    {
                        isFirst = false;
                    }
                    else
                    {
                        code.AppendLine();
                    }

                    code.AppendLine("/// <summary>");
                    code.AppendLine($"/// Atomically generated smart tag with value {comments.Escape(tag.Name.ValueToString())}.");
                    if (tagToDependencies.TryGetValue(tag.Name, out var dependenciesByComposition))
                    {
                        code.AppendLine("/// It's used for:");
                        code.AppendLine("/// <br/>");
                        foreach (var (composition, dependencies) in dependenciesByComposition)
                        {
                            code.AppendLine("/// <br/>");
                            code.AppendLine($"/// class {formatter.FormatRef(composition.Source.Source.Name.FullName)}");
                            code.AppendLine("/// <list type=\"number\">");
                            foreach (var dependency in dependencies)
                            {
                                code.AppendLine(dependency);
                            }

                            code.AppendLine("/// </list>");
                        }
                    }

                    code.AppendLine("/// </summary>");
                    code.AppendLine($"public const string {tag.Name} = {tag.Name.ValueToString()};");
                }
            }

            code.AppendLine("}");
        }

        code.AppendLine("}");

        return new TagCode(code);
    }
}