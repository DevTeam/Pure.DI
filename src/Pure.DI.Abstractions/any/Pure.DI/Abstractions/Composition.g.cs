// <auto-generated/>
// #pragma warning disable
#if !PUREDI_API_SUPPRESSION || PUREDI_API_V1
#pragma warning disable
namespace Pure.DI.Abstractions
{
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal static class Composition
    {
        [global::System.Diagnostics.Conditional("A2768DE22DE3E430C9653990D516CC9B")]
        private static void Setup()
        {
            global::Pure.DI.DI.Setup(kind: global::Pure.DI.CompositionKind.Global)
                .GenericTypeArgumentAttribute<global::Pure.DI.Abstractions.GenericTypeArgumentAttribute>()
                .TagAttribute<global::Pure.DI.Abstractions.InjectAttribute<TT>>()
                .OrdinalAttribute<global::Pure.DI.Abstractions.InjectAttribute<TT>>(1)
                .TypeAttribute<global::Pure.DI.Abstractions.InjectAttribute<TT>>()
                .TagAttribute<global::Pure.DI.Abstractions.InjectAttribute>()
                .OrdinalAttribute<global::Pure.DI.Abstractions.InjectAttribute>(1)
                .Accumulate<global::System.IDisposable, global::Pure.DI.Abstractions.Own>(
                    Lifetime.Transient,
                    Lifetime.PerResolve,
                    Lifetime.PerBlock)
#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                .Accumulate<global::System.IAsyncDisposable, global::Pure.DI.Abstractions.Own>(
                    Lifetime.Transient,
                    Lifetime.PerResolve,
                    Lifetime.PerBlock)
#endif
                .Bind<global::Pure.DI.Abstractions.IOwn>().To((global::Pure.DI.Abstractions.Own own) => own)
                    .Bind<global::Pure.DI.Abstractions.Own<TT>>()
                    .As(Lifetime.PerBlock)
                    .To(ctx => {
                        // Creates the owner of an instance
                        ctx.Inject<global::Pure.DI.Abstractions.Own>(out var own);
                        ctx.Inject<TT>(ctx.Tag, out var value);
                        return new global::Pure.DI.Abstractions.Own<TT>(value, own);
                    });
        }
    }
}
#pragma warning restore
#endif