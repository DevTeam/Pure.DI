// <auto-generated/>
// #pragma warning disable

namespace Pure.DI.MS;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;

/// <summary>
/// Creates a service collection <see cref="Microsoft.Extensions.DependencyInjection.ServiceCollection"/> based resolvers.
/// </summary>
/// <typeparam name="TComposition">The composition class itself.</typeparam>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
internal class ServiceCollectionFactory<TComposition>
{
    private static readonly Func<TComposition, InstanceResolver, ServiceDescriptor> ServiceDescriptorProvider;
    
    static ServiceCollectionFactory()
    {
        var resolverType = typeof(Func<IServiceProvider, object, object>);
        var ctorWithTag = (
            from ctor in typeof(ServiceDescriptor).GetConstructors(BindingFlags.Instance | BindingFlags.Public)
            let parameters = ctor.GetParameters()
            where parameters.Length == 4 
                  && parameters[0].ParameterType == typeof(Type)
                  && parameters[1].ParameterType == typeof(object)
                  && parameters[2].ParameterType == resolverType
                  && parameters[3].ParameterType == typeof(ServiceLifetime)
            select ctor)
        .FirstOrDefault();

        if (ctorWithTag != null)
        {
            var compositionParameter = Expression.Parameter(typeof(TComposition));
            var resolverParameter = Expression.Parameter(typeof(InstanceResolver));
            ServiceDescriptorProvider = Expression.Lambda<Func<TComposition, InstanceResolver, ServiceDescriptor>>(
                    Expression.New(
                        ctorWithTag,
                        Expression.Field(resolverParameter, nameof(InstanceResolver.Type)),
                        Expression.Field(resolverParameter, nameof(InstanceResolver.Tag)),
                        Expression.Lambda(
                            resolverType,
                            Expression.Call(
                                Expression.Field(resolverParameter, nameof(InstanceResolver.Resolver)),
                                typeof(IResolver<TComposition, object>).GetMethod(nameof(IResolver<TComposition, object>.ResolveByTag), BindingFlags.Instance | BindingFlags.Public),
                                compositionParameter,
                                Expression.Field(resolverParameter, nameof(InstanceResolver.Tag))),
                            Expression.Parameter(typeof(IServiceProvider)),
                            Expression.Parameter(typeof(object))),
                        Expression.Constant(ServiceLifetime.Transient)),
            compositionParameter,
                    resolverParameter)
                .Compile();
        }
        else
        {
            ServiceDescriptorProvider = new Func<TComposition, InstanceResolver, ServiceDescriptor>((composition, instanceResolver) => 
                new ServiceDescriptor(
                    instanceResolver.Type,
                    _ => instanceResolver.Resolver.Resolve(composition),
                    ServiceLifetime.Transient));
        }
    }
        
    /// <summary>
    /// A list of instance resolvers, specifying the type of object that the resolver returns.
    /// </summary>
    private readonly List<InstanceResolver> _resolvers = new List<InstanceResolver>();
    
    /// <summary>
    /// Registers the resolver of a composition for use in a collection of services.
    /// </summary>
    /// <param name="resolver">Instance resolver.</param>
    /// <param name="tag">The resolving tag.</param>
    /// <typeparam name="TContract">The type of object that the resolver returns.</typeparam>
    [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)0x100)]
    public void AddResolver<TContract>(IResolver<TComposition, TContract> resolver, object tag = default)
    {
        _resolvers.Add(new InstanceResolver(typeof(TContract), (IResolver<TComposition, object>)resolver, tag));
    }

    /// <summary>3
    /// Creates a service collection <see cref="Microsoft.Extensions.DependencyInjection.ServiceCollection"/> based on all previously registered resolvers.
    /// </summary>
    /// <param name="composition">An instance of composition.</param>
    /// <returns>An instance of <see cref="Microsoft.Extensions.DependencyInjection.ServiceCollection"/>.</returns>
#if NETSTANDARD2_0_OR_GREATER || NETCOREAPP || NET40_OR_GREATER || NET
    [global::System.Diagnostics.Contracts.Pure]
#endif
    [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)0x100)]
    public IServiceCollection CreateServiceCollection(TComposition composition)
    {
        return new ServiceCollection().Add(CreateDescriptors(composition));
    }

    /// <summary>
    /// Creates an enumeration of service descriptors based on all previously registered resolvers.
    /// </summary>
    /// <param name="composition">An instance of composition.</param>
    /// <returns>A enumeration of <see cref="Microsoft.Extensions.DependencyInjection.ServiceDescriptor"/>.</returns>
    [global::System.Runtime.CompilerServices.MethodImpl((global::System.Runtime.CompilerServices.MethodImplOptions)0x100)]
    private IEnumerable<ServiceDescriptor> CreateDescriptors(TComposition composition)
    {
        return _resolvers.Select(resolver => ServiceDescriptorProvider(composition, resolver));
    }

    private struct InstanceResolver
    {
        public readonly Type Type;
        public readonly IResolver<TComposition, object> Resolver;
        public readonly object Tag;

        public InstanceResolver(Type type, IResolver<TComposition, object> resolver, object tag)
        {
            Type = type;
            Resolver = resolver;
            Tag = tag;
        }
    }
}

// #pragma warning restore