// <auto-generated/>
#pragma warning disable CS8669
namespace Pure.DI.MS
{
    using System;
    using System.Linq.Expressions;
    using System.Reflection;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.DependencyInjection.Extensions;

    /// <summary>
    /// A base class for a composition that can be used as a service provider factory <see cref="Microsoft.Extensions.DependencyInjection.IServiceProviderFactory{TContainerBuilder}"/>.
    /// <example>
    /// <code>
    /// partial class Composition: ServiceProviderFactory&lt;Composition&gt;
    /// {
    ///     void Setup() =&gt; DI.Setup()
    ///         .Bind().As(Singleton).To&lt;WeatherForecastService&gt;()
    ///         // Registers controllers as roots
    ///         .Roots&lt;ControllerBase&gt;();
    /// }
    /// </code>
    /// </example> 
    /// </summary>
    /// <typeparam name="TComposition">Composition class type.</typeparam>
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    public class ServiceProviderFactory<TComposition>: IServiceProviderFactory<IServiceCollection>
        where TComposition: ServiceProviderFactory<TComposition>
    {
        private static readonly Type KeyedServiceProviderType = Type.GetType("Microsoft.Extensions.DependencyInjection.IKeyedServiceProvider, Microsoft.Extensions.DependencyInjection.Abstractions, Culture=neutral, PublicKeyToken=adb9793829ddae60", false);
        private static readonly MethodInfo GetKeyedServiceMethod = KeyedServiceProviderType?.GetMethod("GetKeyedService");
        private static readonly ParameterExpression TypeParameter = Expression.Parameter(typeof(Type));
        private static readonly ParameterExpression TagParameter = Expression.Parameter(typeof(object));
    
        /// <summary>
        /// The name of the setup to use as the dependency name in a dependent setup.
        /// <example>
        /// For example,
        /// <code>
        /// void Setup() =&amp;gt;
        ///     DI.Setup(nameof(Composition))
        ///         // Use the DI setup from the base class
        ///         .DependsOn(Base);
        /// </code>
        /// </example>
        /// </summary>
        [Obsolete("Since Pure.DI 2.2.7 using the Base value is not necessary in the DependsOn invocation, thus you can skip this invocation.")]
        protected const string Base = "Pure.DI.MS.ServiceProviderFactory";
    
        /// <summary>
        /// An instance of <see cref="ServiceCollectionFactory{TComposition}"/>.
        /// </summary>
        private static readonly ServiceCollectionFactory<TComposition> ServiceCollectionFactory = new global::Pure.DI.MS.ServiceCollectionFactory<TComposition>();

        /// <summary>
        /// Instance for thread synchronization.
        /// </summary>
        private readonly global::System.Object _lock = new global::System.Object();
    
        /// <summary>
        /// <see cref="System.IServiceProvider"/> instance for resolving external dependencies.
        /// </summary>
        private Func<Type, object, object?>? _instanceResolver;

        /// <summary>
        ///  Defines a mechanism for retrieving a service object.
        /// </summary>
        private IServiceProvider _serviceProvider;

        /// <summary>
        /// Allows getting or setting a service provider.
        /// </summary>
        /// <exception cref="InvalidOperationException">Throws an exception if the service provider is not yet defined when attempting to get it.</exception>
        public IServiceProvider ServiceProvider
        {
            get
            {
                return _serviceProvider ?? throw new InvalidOperationException("The service provider has not yet been defined.");
            }
            set
            {
                _serviceProvider = value;
                var instanceResolver = CreateInstanceResolver(value);
                lock (_lock)
                {
                    _instanceResolver = instanceResolver;
                }
            }
        }

        private static Func<Type, object, object> CreateInstanceResolver(IServiceProvider serviceProvider)
        {
            return KeyedServiceProviderType?.IsAssignableFrom(serviceProvider.GetType()) == true
                ? Expression.Lambda<Func<Type, object, object>>(
                    Expression.Call(Expression.Constant(serviceProvider), GetKeyedServiceMethod, TypeParameter, TagParameter),
                    TypeParameter,
                    TagParameter).Compile()
                : new Func<Type, object, object>((type, tag) => serviceProvider.GetService(type));
        }

        /// <summary>
        /// DI setup hints.
        /// </summary>
        [global::System.Diagnostics.Conditional("A2768DE22DE3E430C9653990D516CC9B")]
        private static void HintsSetup()
        {
            global::Pure.DI.DI.Setup(kind: global::Pure.DI.CompositionKind.Internal)
                .Hint(global::Pure.DI.Hint.OnCannotResolve, "On")
                .Hint(global::Pure.DI.Hint.OnCannotResolvePartial, "Off")
                .Hint(global::Pure.DI.Hint.OnNewRoot, "On")
                .Hint(global::Pure.DI.Hint.OnNewRootPartial, "Off")
                // Specifies not to attempt to resolve types whose fully qualified name
                // begins with Microsoft.Extensions, Microsoft.AspNetCore, Microsoft.Maui
                // since ServiceProvider will be used to retrieve them.
                .Hint(global::Pure.DI.Hint.OnCannotResolveContractTypeNameWildcard, "Microsoft.Extensions.*")
                .Hint(global::Pure.DI.Hint.OnCannotResolveContractTypeNameWildcard, "Microsoft.AspNetCore.*")
                .Hint(global::Pure.DI.Hint.OnCannotResolveContractTypeNameWildcard, "Microsoft.Maui.*")
                .Hint(global::Pure.DI.Hint.OnCannotResolveContractTypeNameWildcard, "Microsoft.EntityFrameworkCore.*");
        }

        /// <summary>
        /// Creates a service collection <see cref="Microsoft.Extensions.DependencyInjection.ServiceCollection"/> based on the registered composition.
        /// </summary>
        /// <param name="composition">An instance of composition.</param>
        /// <returns>An instance of <see cref="Microsoft.Extensions.DependencyInjection.ServiceCollection"/>.</returns>
#if NETSTANDARD2_0_OR_GREATER || NETCOREAPP || NET40_OR_GREATER || NET
        [global::System.Diagnostics.Contracts.Pure]
#endif
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        protected static IServiceCollection CreateServiceCollection(TComposition composition)
        {
            if (composition == null) throw new ArgumentNullException(nameof(composition));
            return ServiceCollectionFactory.CreateServiceCollection(composition);
        }

        /// <inheritdoc />
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public IServiceCollection CreateBuilder(IServiceCollection services)
        {
            if (services == null) throw new ArgumentNullException(nameof(services));
            // Registers composition roots as services in the service collection.
            return services.Add(CreateServiceCollection((TComposition)this));
        }

        /// <inheritdoc />
        /// <exception cref="ArgumentNullException">Throws an exception if the service collection is null.</exception>
        /// <exception cref="InvalidOperationException">Throws an exception if services are already defined.</exception>
        public IServiceProvider CreateServiceProvider(IServiceCollection services)
        {
            if (services == null) throw new ArgumentNullException(nameof(services));
            lock (_lock)
            {
                if (_instanceResolver is not null)
                {
                    throw new InvalidOperationException("Services have already been defined.");
                }

                return ServiceProvider = services.BuildServiceProvider();
            }
        }

        /// <summary>
        /// Used to resolve external dependencies using the service provider <see cref="System.IServiceProvider"/>.
        /// </summary>
        /// <param name="tag">Dependency resolution tag.</param>
        /// <param name="lifetime">Dependency resolution lifetime.</param>
        /// <typeparam name="T">Dependency resolution type.</typeparam>
        /// <returns>Resolved dependency instance.</returns>
        /// <exception cref="InvalidOperationException">Throws an exception if the service provider is not yet defined when attempting to get it.</exception>
        /// <exception cref="CannotResolveException">Will be thrown if the corresponding composition root was not specified.</exception>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        internal T OnCannotResolve<T>(object? tag, Lifetime lifetime)
        {
            Func<Type, object, object?>? serviceProvider;
            lock (_lock)
            {
                serviceProvider = _instanceResolver ?? throw new InvalidOperationException("Services have not yet been defined.");
            }

            return (T)(serviceProvider(typeof(T), tag)
                   ?? throw new CannotResolveException($"No composition root or service is registered for type {typeof(T)}{(tag == null ? "" : $"({tag})")}."));
        }

        /// <summary>
        /// Registers a composition resolver for use in a service collection <see cref="Microsoft.Extensions.DependencyInjection.ServiceCollection"/>.
        /// </summary>
        /// <param name="resolver">Instance resolver.</param>
        /// <param name="name">The name of the composition root.</param>
        /// <param name="tag">The tag of the composition root.</param>
        /// <param name="lifetime">The lifetime of the composition root.</param>
        /// <typeparam name="TContract">The contract type of the composition root.</typeparam>
        /// <typeparam name="T">The implementation type of the composition root.</typeparam>
        /// <exception cref="ArgumentNullException">Throws an exception if the instance resolver is null.</exception>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        internal static void OnNewRoot<TContract, T>(
            IResolver<TComposition, TContract> resolver,
            string name, object tag, Lifetime lifetime)
        {
            if (resolver == null) throw new ArgumentNullException(nameof(resolver));
            ServiceCollectionFactory.AddResolver(resolver, tag);
        }
    }
#pragma warning restore
}